###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       14/Dec/2023  19:58:49
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\USER\map.c
#    Command line =  
#        -f C:\Users\user\AppData\Local\Temp\EWCA24.tmp
#        (C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\USER\map.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\Debug\List -o
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\LCD\
#        -I C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\user\ -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\user\inc\ -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\ -I
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\USER\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\Debug\List\map.lst
#    Object file  =  
#        C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\Debug\Obj\map.o
#
###############################################################################

C:\Users\user\Desktop\1214\testing-ground-main\PROJECT\libraries\USER\map.c
      1          #include "map.h"
      2          #include <math.h>
      3          

   \                                 In section .bss, align 4
      4          Point source_Map[MAP_SIZE];
   \                     source_Map:
   \   00000000                      DS8 800

   \                                 In section .bss, align 4
      5          int source_Map_size;
   \                     source_Map_size:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
      6          int source_Map_Idx = 0;
   \                     source_Map_Idx:
   \   00000000                      DS8 4
      7          

   \                                 In section .bss, align 4
      8          Point target_Map[MAP_SIZE];
   \                     target_Map:
   \   00000000                      DS8 800

   \                                 In section .bss, align 4
      9          int target_Map_size;
   \                     target_Map_size:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     10          int target_Map_Idx = 0;
   \                     target_Map_Idx:
   \   00000000                      DS8 4
     11          

   \                                 In section .rodata, align 4
     12          const Point init_map[4] = {{0, 0}, {0, Y_MAX}, {X_MAX, Y_MAX}, {X_MAX, 0}};
   \                     init_map:
   \   00000000   0x00000000         DC32 0H, 0H, 0H, 42C80000H, 42C80000H, 42C80000H, 42C80000H, 0H
   \              0x00000000   
   \              0x00000000   
   \              0x42C80000   
   \              0x42C80000   
   \              0x42C80000   
   \              0x42C80000   
   \              0x00000000   
     13          

   \                                 In section .bss, align 4
     14          static Point stack[MAP_SIZE];
   \                     stack:
   \   00000000                      DS8 800

   \                                 In section .bss, align 4
     15          static int stack_top = 0;
   \                     stack_top:
   \   00000000                      DS8 4
     16          

   \                                 In section .text, align 2, keep-with-next
     17          int getCCW(Point p1, Point p2, Point p3)
     18          {
   \                     getCCW: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
   \   0000000C   0xE9DD 0x670A      LDRD     R6,R7,[SP, #+40]
     19              float temp = p1.x * p2.y - p1.y * p2.x;
   \   00000010   0x4641             MOV      R1,R8
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       __aeabi_fmul
   \   00000018   0x4682             MOV      R10,R0
   \   0000001A   0x4649             MOV      R1,R9
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       __aeabi_fmul
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0x4650             MOV      R0,R10
   \   00000026   0x.... 0x....      BL       __aeabi_fsub
   \   0000002A   0x4682             MOV      R10,R0
     20              temp += p2.x * p3.y - p2.y * p3.x;
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x.... 0x....      BL       __aeabi_fmul
   \   00000034   0x4683             MOV      R11,R0
   \   00000036   0x0029             MOVS     R1,R5
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       __aeabi_fmul
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0x4651             MOV      R1,R10
   \   00000048   0x.... 0x....      BL       __aeabi_fadd
   \   0000004C   0x0004             MOVS     R4,R0
     21              temp += p3.x * p1.y - p3.y * p1.x;
   \   0000004E   0x0031             MOVS     R1,R6
   \   00000050   0x4648             MOV      R0,R9
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x0005             MOVS     R5,R0
   \   00000058   0x0039             MOVS     R1,R7
   \   0000005A   0x4640             MOV      R0,R8
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       __aeabi_fsub
   \   00000068   0x0021             MOVS     R1,R4
   \   0000006A   0x.... 0x....      BL       __aeabi_fadd
     22          
     23              if (temp > CCW_THRESHOLD) return 1;
   \   0000006E   0x....             LDR.N    R1,??DataTable3  ;; 0x3dcccccd
   \   00000070   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000074   0xD801             BHI.N    ??getCCW_0
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE007             B.N      ??getCCW_1
     24              else if (temp < CCW_THRESHOLD) return -1;
   \                     ??getCCW_0: (+1)
   \   0000007A   0x....             LDR.N    R1,??DataTable3  ;; 0x3dcccccd
   \   0000007C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000080   0xD202             BCS.N    ??getCCW_2
   \   00000082   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000086   0xE000             B.N      ??getCCW_1
     25          
     26              return 0;
   \                     ??getCCW_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??getCCW_1: (+1)
   \   0000008A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
     27          }
     28          

   \                                 In section .text, align 2, keep-with-next
     29          float getDistance(Point p1, Point p2)
     30          {
   \                     getDistance: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     31              return sqrtf(powf(p1.x - p2.x, 2) + powf(p1.y - p2.y, 2));
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0x.... 0x....      BL       __aeabi_fsub
   \   00000014   0x4680             MOV      R8,R0
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x0039             MOVS     R1,R7
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x0004             MOVS     R4,R0
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x.... 0x....      BL       __aeabi_fmul
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x.... 0x....      BL       sqrtf
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     32          }
     33          

   \                                 In section .text, align 2, keep-with-next
     34          void initMap(Point *map, int *map_size, int *map_Idx)
     35          {
   \                     initMap: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
     36              int size = *map_size = 4;
   \   00000002   0x2304             MOVS     R3,#+4
   \   00000004   0x600B             STR      R3,[R1, #+0]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
     37          
     38              for(*map_Idx = 0; *map_Idx < size; (*map_Idx)++) {
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x6013             STR      R3,[R2, #+0]
   \   0000000C   0xE00D             B.N      ??initMap_0
     39                  map[*map_Idx] = init_map[*map_Idx];
   \                     ??initMap_1: (+1)
   \   0000000E   0x....             LDR.N    R3,??DataTable3_1
   \   00000010   0x6814             LDR      R4,[R2, #+0]
   \   00000012   0xEB03 0x03C4      ADD      R3,R3,R4, LSL #+3
   \   00000016   0xE9D3 0x4500      LDRD     R4,R5,[R3, #+0]
   \   0000001A   0x6813             LDR      R3,[R2, #+0]
   \   0000001C   0xEB00 0x03C3      ADD      R3,R0,R3, LSL #+3
   \   00000020   0xE9C3 0x4500      STRD     R4,R5,[R3, #+0]
     40              }
   \   00000024   0x6813             LDR      R3,[R2, #+0]
   \   00000026   0x1C5B             ADDS     R3,R3,#+1
   \   00000028   0x6013             STR      R3,[R2, #+0]
   \                     ??initMap_0: (+1)
   \   0000002A   0x6813             LDR      R3,[R2, #+0]
   \   0000002C   0x428B             CMP      R3,R1
   \   0000002E   0xDBEE             BLT.N    ??initMap_1
     41          }
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
     42          

   \                                 In section .text, align 2, keep-with-next
     43          void sortMap(Point *map, const int *map_size)
     44          {
   \                     sortMap: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0002             MOVS     R2,R0
     45              int size = *map_size;
   \   00000004   0x680B             LDR      R3,[R1, #+0]
     46          
     47              for (int i = 0; i < size; i++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE01A             B.N      ??sortMap_0
     48                  for (int j = i + 1; j < size; j++) {
     49                      if (map[i].x > map[j].x) {
   \                     ??sortMap_1: (+1)
   \   0000000A   0xF852 0x0037      LDR      R0,[R2, R7, LSL #+3]
   \   0000000E   0xF852 0x1036      LDR      R1,[R2, R6, LSL #+3]
   \   00000012   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000016   0xD20F             BCS.N    ??sortMap_2
     50                          Point tmp = map[i];
   \   00000018   0xEB02 0x04C6      ADD      R4,R2,R6, LSL #+3
   \   0000001C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
     51                          map[i] = map[j];
   \   00000020   0xEB02 0x0CC7      ADD      R12,R2,R7, LSL #+3
   \   00000024   0xE9DC 0x4500      LDRD     R4,R5,[R12, #+0]
   \   00000028   0xEB02 0x0CC6      ADD      R12,R2,R6, LSL #+3
   \   0000002C   0xE9CC 0x4500      STRD     R4,R5,[R12, #+0]
     52                          map[j] = tmp;
   \   00000030   0xEB02 0x04C7      ADD      R4,R2,R7, LSL #+3
   \   00000034   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
     53                      }
     54                  }
   \                     ??sortMap_2: (+1)
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \                     ??sortMap_3: (+1)
   \   0000003A   0x429F             CMP      R7,R3
   \   0000003C   0xDBE5             BLT.N    ??sortMap_1
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMap_0: (+1)
   \   00000040   0x429E             CMP      R6,R3
   \   00000042   0xDA01             BGE.N    ??sortMap_4
   \   00000044   0x1C77             ADDS     R7,R6,#+1
   \   00000046   0xE7F8             B.N      ??sortMap_3
     55              }
     56          }
   \                     ??sortMap_4: (+1)
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     57          

   \                                 In section .text, align 2, keep-with-next
     58          void sortMapByX(Point *map, const int *map_size)
     59          {
   \                     sortMapByX: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0002             MOVS     R2,R0
     60              int size = *map_size;
   \   00000004   0x680B             LDR      R3,[R1, #+0]
     61          
     62              for (int i = 0; i < size; i++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE01A             B.N      ??sortMapByX_0
     63                  for (int j = i + 1; j < size; j++) {
     64                      if (map[i].x > map[j].x) {
   \                     ??sortMapByX_1: (+1)
   \   0000000A   0xF852 0x0037      LDR      R0,[R2, R7, LSL #+3]
   \   0000000E   0xF852 0x1036      LDR      R1,[R2, R6, LSL #+3]
   \   00000012   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000016   0xD20F             BCS.N    ??sortMapByX_2
     65                          Point tmp = map[i];
   \   00000018   0xEB02 0x04C6      ADD      R4,R2,R6, LSL #+3
   \   0000001C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
     66                          map[i] = map[j];
   \   00000020   0xEB02 0x0CC7      ADD      R12,R2,R7, LSL #+3
   \   00000024   0xE9DC 0x4500      LDRD     R4,R5,[R12, #+0]
   \   00000028   0xEB02 0x0CC6      ADD      R12,R2,R6, LSL #+3
   \   0000002C   0xE9CC 0x4500      STRD     R4,R5,[R12, #+0]
     67                          map[j] = tmp;
   \   00000030   0xEB02 0x04C7      ADD      R4,R2,R7, LSL #+3
   \   00000034   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
     68                      }
     69                  }
   \                     ??sortMapByX_2: (+1)
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \                     ??sortMapByX_3: (+1)
   \   0000003A   0x429F             CMP      R7,R3
   \   0000003C   0xDBE5             BLT.N    ??sortMapByX_1
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMapByX_0: (+1)
   \   00000040   0x429E             CMP      R6,R3
   \   00000042   0xDA01             BGE.N    ??sortMapByX_4
   \   00000044   0x1C77             ADDS     R7,R6,#+1
   \   00000046   0xE7F8             B.N      ??sortMapByX_3
     70              }
     71          }
   \                     ??sortMapByX_4: (+1)
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void sortMapByCCW(Point *map, const int *map_size)
     74          {
   \                     sortMapByCCW: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
     75              int size = *map_size;
   \   00000004   0x680F             LDR      R7,[R1, #+0]
     76          
     77              // except i == 0
     78              for (int i = 1; i < size; i++) {
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0xE023             B.N      ??sortMapByCCW_0
     79                  for (int j = i + 1; j < size; j++) {
     80                      if (getCCW(map[0], map[i], map[j]) > 0) {
   \                     ??sortMapByCCW_1: (+1)
   \   0000000A   0xEB04 0x00C6      ADD      R0,R4,R6, LSL #+3
   \   0000000E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000012   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000016   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \   0000001A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000001E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   00000022   0x.... 0x....      BL       getCCW
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xDB0F             BLT.N    ??sortMapByCCW_2
     81                          Point tmp = map[i];
   \   0000002A   0xEB04 0x02C5      ADD      R2,R4,R5, LSL #+3
   \   0000002E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
     82                          map[i] = map[j];
   \   00000032   0xEB04 0x0CC6      ADD      R12,R4,R6, LSL #+3
   \   00000036   0xE9DC 0x2300      LDRD     R2,R3,[R12, #+0]
   \   0000003A   0xEB04 0x0CC5      ADD      R12,R4,R5, LSL #+3
   \   0000003E   0xE9CC 0x2300      STRD     R2,R3,[R12, #+0]
     83                          map[j] = tmp;
   \   00000042   0xEB04 0x02C6      ADD      R2,R4,R6, LSL #+3
   \   00000046   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     84                      }
     85                  }
   \                     ??sortMapByCCW_2: (+1)
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMapByCCW_3: (+1)
   \   0000004C   0x42BE             CMP      R6,R7
   \   0000004E   0xDBDC             BLT.N    ??sortMapByCCW_1
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \                     ??sortMapByCCW_0: (+1)
   \   00000052   0x42BD             CMP      R5,R7
   \   00000054   0xDA01             BGE.N    ??sortMapByCCW_4
   \   00000056   0x1C6E             ADDS     R6,R5,#+1
   \   00000058   0xE7F8             B.N      ??sortMapByCCW_3
     86              }
     87          }
   \                     ??sortMapByCCW_4: (+1)
   \   0000005A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
     88          
     89          //assign convex hull using by Graham's Scan Algorithm

   \                                 In section .text, align 2, keep-with-next
     90          void assignConvexHull(Point *map, int *map_size)
     91          {
   \                     assignConvexHull: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     92              int size = *map_size;
   \   00000006   0x682F             LDR      R7,[R5, #+0]
     93          
     94              //sort map by x
     95              sortMapByX(map, map_size);
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       sortMapByX
     96              //sort map by ccw
     97              sortMapByCCW(map, map_size);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       sortMapByCCW
     98          
     99              //assign convex hull
    100              stack[stack_top++] = map[0];
   \   00000018   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   0000001C   0x....             LDR.N    R2,??DataTable3_2
   \   0000001E   0x....             LDR.N    R3,??DataTable3_3
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \   00000026   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable3_3
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable3_3
   \   00000032   0x6008             STR      R0,[R1, #+0]
    101              stack[stack_top++] = map[1];
   \   00000034   0xE9D4 0x0102      LDRD     R0,R1,[R4, #+8]
   \   00000038   0x....             LDR.N    R2,??DataTable3_2
   \   0000003A   0x....             LDR.N    R3,??DataTable3_3
   \   0000003C   0x681B             LDR      R3,[R3, #+0]
   \   0000003E   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \   00000042   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \   00000046   0x....             LDR.N    R0,??DataTable3_3
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R1,??DataTable3_3
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    102              for (int i = 2; i < size; i++) {
   \   00000050   0x2602             MOVS     R6,#+2
   \   00000052   0xE034             B.N      ??assignConvexHull_0
    103                  while (stack_top >= 2 && getCCW(stack[stack_top - 2], stack[stack_top - 1], map[i]) <= 0) {
    104                      stack_top--;
   \                     ??assignConvexHull_1: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable3_3
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable3_3
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    105                  }
   \                     ??assignConvexHull_2: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable3_3
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xDB1A             BLT.N    ??assignConvexHull_3
   \   00000066   0xEB04 0x00C6      ADD      R0,R4,R6, LSL #+3
   \   0000006A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000006E   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000072   0x....             LDR.N    R0,??DataTable3_2
   \   00000074   0x....             LDR.N    R1,??DataTable3_3
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000007C   0x3808             SUBS     R0,R0,#+8
   \   0000007E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000082   0x....             LDR.N    R0,??DataTable3_2
   \   00000084   0x....             LDR.N    R1,??DataTable3_3
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000008C   0xF1B0 0x0C10      SUBS     R12,R0,#+16
   \   00000090   0xE9DC 0x0100      LDRD     R0,R1,[R12, #+0]
   \   00000094   0x.... 0x....      BL       getCCW
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xDBDB             BLT.N    ??assignConvexHull_1
    106                  stack[stack_top++] = map[i];
   \                     ??assignConvexHull_3: (+1)
   \   0000009C   0xEB04 0x02C6      ADD      R2,R4,R6, LSL #+3
   \   000000A0   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   000000A4   0x....             LDR.N    R2,??DataTable3_2
   \   000000A6   0x....             LDR.N    R3,??DataTable3_3
   \   000000A8   0x681B             LDR      R3,[R3, #+0]
   \   000000AA   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \   000000AE   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \   000000B2   0x....             LDR.N    R0,??DataTable3_3
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x....             LDR.N    R1,??DataTable3_3
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    107              }
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
   \                     ??assignConvexHull_0: (+1)
   \   000000BE   0x42BE             CMP      R6,R7
   \   000000C0   0xDBCD             BLT.N    ??assignConvexHull_2
    108          
    109              //assign convex hull
    110              for (int i = 0; i < stack_top; i++) {
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xE009             B.N      ??assignConvexHull_4
    111                  map[i] = stack[i];
   \                     ??assignConvexHull_5: (+1)
   \   000000C6   0x....             LDR.N    R1,??DataTable3_2
   \   000000C8   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \   000000CC   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \   000000D0   0xEB04 0x01C0      ADD      R1,R4,R0, LSL #+3
   \   000000D4   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
    112              }
   \   000000D8   0x1C40             ADDS     R0,R0,#+1
   \                     ??assignConvexHull_4: (+1)
   \   000000DA   0x....             LDR.N    R1,??DataTable3_3
   \   000000DC   0x6809             LDR      R1,[R1, #+0]
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xDBF1             BLT.N    ??assignConvexHull_5
    113          
    114              *map_size = stack_top;
   \   000000E2   0x....             LDR.N    R0,??DataTable3_3
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x6028             STR      R0,[R5, #+0]
    115          
    116              stack_top = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x....             LDR.N    R1,??DataTable3_3
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    117          }
   \   000000EE   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void calcAndStoreMidPoints(Point *map_Source, Point *map_Target, const int *map_SourceSize, int *map_TargetSize)
    120          {
   \                     calcAndStoreMidPoints: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x469A             MOV      R10,R3
    121              int size = *map_SourceSize;
   \   0000000A   0x6815             LDR      R5,[R2, #+0]
    122              int targetIndex = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
    123          
    124              for (int i = 0; i < size; i++) {
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xE042             B.N      ??calcAndStoreMidPoints_0
    125                  Point midPoint;
    126                  midPoint.x = (map_Source[(i - 1 + size) % size].x + map_Source[(i + 1) % size].x) / 2;
   \                     ??calcAndStoreMidPoints_1: (+1)
   \   00000012   0x19A8             ADDS     R0,R5,R6
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x1C72             ADDS     R2,R6,#+1
   \   00000018   0xFB90 0xF1F5      SDIV     R1,R0,R5
   \   0000001C   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   00000020   0xF857 0x1030      LDR      R1,[R7, R0, LSL #+3]
   \   00000024   0xFB92 0xF0F5      SDIV     R0,R2,R5
   \   00000028   0xFB05 0x2210      MLS      R2,R5,R0,R2
   \   0000002C   0xF857 0x0032      LDR      R0,[R7, R2, LSL #+3]
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000038   0x.... 0x....      BL       __aeabi_fdiv
   \   0000003C   0x4680             MOV      R8,R0
    127                  midPoint.y = (map_Source[(i - 1 + size) % size].y + map_Source[(i + 1) % size].y) / 2;
   \   0000003E   0x19A8             ADDS     R0,R5,R6
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x1C71             ADDS     R1,R6,#+1
   \   00000044   0xFB90 0xF2F5      SDIV     R2,R0,R5
   \   00000048   0xFB05 0x0012      MLS      R0,R5,R2,R0
   \   0000004C   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \   00000050   0x6840             LDR      R0,[R0, #+4]
   \   00000052   0xFB91 0xF2F5      SDIV     R2,R1,R5
   \   00000056   0xFB05 0x1112      MLS      R1,R5,R2,R1
   \   0000005A   0xEB07 0x01C1      ADD      R1,R7,R1, LSL #+3
   \   0000005E   0x6849             LDR      R1,[R1, #+4]
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000068   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006C   0x4681             MOV      R9,R0
    128                  
    129                  if (targetIndex == 0 || getDistance(midPoint, map_Target[targetIndex - 1]) > THRESHOLD) {
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD00C             BEQ.N    ??calcAndStoreMidPoints_2
   \   00000072   0xEB0B 0x00C4      ADD      R0,R11,R4, LSL #+3
   \   00000076   0x3808             SUBS     R0,R0,#+8
   \   00000078   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x4649             MOV      R1,R9
   \   00000080   0x.... 0x....      BL       getDistance
   \   00000084   0x....             LDR.N    R1,??DataTable3  ;; 0x3dcccccd
   \   00000086   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000008A   0xD804             BHI.N    ??calcAndStoreMidPoints_3
    130                      map_Target[targetIndex++] = midPoint;
   \                     ??calcAndStoreMidPoints_2: (+1)
   \   0000008C   0xEB0B 0x00C4      ADD      R0,R11,R4, LSL #+3
   \   00000090   0xE9C0 0x8900      STRD     R8,R9,[R0, #+0]
   \   00000094   0x1C64             ADDS     R4,R4,#+1
    131                  }
    132              }
   \                     ??calcAndStoreMidPoints_3: (+1)
   \   00000096   0x1C76             ADDS     R6,R6,#+1
   \                     ??calcAndStoreMidPoints_0: (+1)
   \   00000098   0x42AE             CMP      R6,R5
   \   0000009A   0xDBBA             BLT.N    ??calcAndStoreMidPoints_1
    133          
    134              *map_TargetSize = targetIndex;
   \   0000009C   0xF8CA 0x4000      STR      R4,[R10, #+0]
    135          }
   \   000000A0   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     init_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     stack_top

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   assignConvexHull
        32   -> getCCW
        32   -> sortMapByCCW
        32   -> sortMapByX
      40   calcAndStoreMidPoints
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> getDistance
        40 __aeabi_cfrcmple
      40   getCCW
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40 __aeabi_cfcmple
        40 __aeabi_cfrcmple
      24   getDistance
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
        24   -> sqrtf
       8   initMap
      24   sortMap
        24 __aeabi_cfcmple
      32   sortMapByCCW
        32   -> getCCW
      24   sortMapByX
        24 __aeabi_cfcmple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
     240  assignConvexHull
     164  calcAndStoreMidPoints
     142  getCCW
      64  getDistance
      52  initMap
      32  init_map
      74  sortMap
      92  sortMapByCCW
      74  sortMapByX
     800  source_Map
       4  source_Map_Idx
       4  source_Map_size
     800  stack
       4  stack_top
     800  target_Map
       4  target_Map_Idx
       4  target_Map_size

 
 2 420 bytes in section .bss
    32 bytes in section .rodata
   918 bytes in section .text
 
   918 bytes of CODE  memory
    32 bytes of CONST memory
 2 420 bytes of DATA  memory

Errors: none
Warnings: none
