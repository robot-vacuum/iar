###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         22/Dec/2023  02:57:06
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\USER\map.c
#    Command line      =
#        -f
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\Obj\libraries\USER\map.o.rsp
#        (c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\USER\map.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\List\libraries\USER
#        -o
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\Obj\libraries\USER
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Normal.h" -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\CMSIS\DeviceSupport\
#        -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\LCD\ -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\user\ -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\user\inc\ -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\ -I
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\USER\ -Ol -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\Obj\libraries\USER\map.o.d
#    Locale            =  C
#    List file         =
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\List\libraries\USER\map.lst
#    Object file       =
#        c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\Debug\Obj\libraries\USER\map.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

c:\Users\hyuunnnn\Documents\GitHub\iar\PROJECT\libraries\USER\map.c
      1          #include "map.h"
      2          
      3          #include <math.h>
      4          

   \                                 In section .bss, align 4
      5          Point source_Map[MAP_SIZE];
   \                     source_Map:
   \        0x0                      DS8 800

   \                                 In section .bss, align 4
      6          int source_Map_size;
   \                     source_Map_size:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
      7          int source_Map_Idx = 0;
   \                     source_Map_Idx:
   \        0x0                      DS8 4
      8          

   \                                 In section .bss, align 4
      9          Point target_Map[MAP_SIZE];
   \                     target_Map:
   \        0x0                      DS8 800

   \                                 In section .bss, align 4
     10          int target_Map_size;
   \                     target_Map_size:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     11          int target_Map_Idx = 0;
   \                     target_Map_Idx:
   \        0x0                      DS8 4
     12          

   \                                 In section .rodata, align 4
     13          const Point init_map[4] = {{0, 0}, {X_MAX, 0}, {X_MAX, Y_MAX}, {0, Y_MAX}};
   \                     init_map:
   \        0x0   0x0000'0000        DC32 0x0, 0x0, 0x447a'0000, 0x0, 0x447a'0000, 0x447a'0000, 0x0

   \              0x0000'0000  

   \              0x447A'0000  

   \              0x0000'0000  

   \              0x447A'0000  

   \              0x447A'0000  

   \              0x0000'0000
   \       0x1C   0x447A'0000        DC32 0x447a'0000
     14          

   \                                 In section .bss, align 4
     15          static Point stack[MAP_SIZE];
   \                     stack:
   \        0x0                      DS8 800

   \                                 In section .bss, align 4
     16          static int stack_top = 0;
   \                     stack_top:
   \        0x0                      DS8 4
     17          

   \                                 In section .text, align 2, keep-with-next
     18          int getCCW(Point p1, Point p2, Point p3) {
   \                     getCCW: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0xE9DD 0x670A      LDRD     R6,R7,[SP, #+40]
     19            float temp = p1.x * p2.y - p1.y * p2.x;
   \       0x10   0x4641             MOV      R1,R8
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       __aeabi_fmul
   \       0x18   0x4682             MOV      R10,R0
   \       0x1A   0x4649             MOV      R1,R9
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       __aeabi_fmul
   \       0x22   0x0001             MOVS     R1,R0
   \       0x24   0x4650             MOV      R0,R10
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x4682             MOV      R10,R0
     20            temp += p2.x * p3.y - p2.y * p3.x;
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x.... 0x....      BL       __aeabi_fmul
   \       0x34   0x4683             MOV      R11,R0
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       __aeabi_fmul
   \       0x3E   0x0001             MOVS     R1,R0
   \       0x40   0x4658             MOV      R0,R11
   \       0x42   0x.... 0x....      BL       __aeabi_fsub
   \       0x46   0x4651             MOV      R1,R10
   \       0x48   0x.... 0x....      BL       __aeabi_fadd
   \       0x4C   0x0004             MOVS     R4,R0
     21            temp += p3.x * p1.y - p3.y * p1.x;
   \       0x4E   0x0031             MOVS     R1,R6
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       __aeabi_fmul
   \       0x56   0x0005             MOVS     R5,R0
   \       0x58   0x0039             MOVS     R1,R7
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x.... 0x....      BL       __aeabi_fmul
   \       0x60   0x0001             MOVS     R1,R0
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x.... 0x....      BL       __aeabi_fsub
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0x.... 0x....      BL       __aeabi_fadd
     22          
     23            if (temp > CCW_THRESHOLD)
   \       0x6E   0x....             LDR.N    R1,??DataTable3
   \       0x70   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x74   0xD801             BHI.N    ??getCCW_0
     24              return 1;
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xE008             B.N      ??getCCW_1
     25            else if (temp < CCW_THRESHOLD)
   \                     ??getCCW_0: (+1)
   \       0x7A   0xF05F 0x517C      MOVS     R1,#+1056964608
   \       0x7E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x82   0xD202             BCS.N    ??getCCW_2
     26              return -1;
   \       0x84   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x88   0xE000             B.N      ??getCCW_1
     27          
     28            return 0;
   \                     ??getCCW_2: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??getCCW_1: (+1)
   \       0x8C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
     29          }
     30          

   \                                 In section .text, align 2, keep-with-next
     31          float getDistance(Point p1, Point p2) { return sqrtf(powf(p1.x - p2.x, 2) + powf(p1.y - p2.y, 2)); }
   \                     getDistance: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x.... 0x....      BL       __aeabi_fsub
   \       0x14   0x4680             MOV      R8,R0
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x0039             MOVS     R1,R7
   \       0x1A   0x.... 0x....      BL       __aeabi_fsub
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x4641             MOV      R1,R8
   \       0x24   0x.... 0x....      BL       __aeabi_fmul
   \       0x28   0x0005             MOVS     R5,R0
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x.... 0x....      BL       __aeabi_fmul
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x.... 0x....      BL       __aeabi_fadd
   \       0x38   0x.... 0x....      BL       sqrtf
   \       0x3C   0xE8BD 0x81F0      POP      {R4-R8,PC}
     32          

   \                                 In section .text, align 2, keep-with-next
     33          void initMap(Point *map, int *map_size, int *map_Idx) {
   \                     initMap: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
     34            int size = *map_size = 4;
   \        0x2   0x2304             MOVS     R3,#+4
   \        0x4   0x600B             STR      R3,[R1, #+0]
     35          
     36            for (*map_Idx = -1; *map_Idx - 1 < size; ) {
   \        0x6   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \        0xA   0x6011             STR      R1,[R2, #+0]
   \        0xC   0xE00D             B.N      ??initMap_0
     37              (*map_Idx)++;
   \                     ??initMap_1: (+1)
   \        0xE   0x6811             LDR      R1,[R2, #+0]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x6011             STR      R1,[R2, #+0]
     38              map[*map_Idx] = init_map[*map_Idx];
   \       0x14   0x....             LDR.N    R1,??DataTable3_1
   \       0x16   0x6814             LDR      R4,[R2, #+0]
   \       0x18   0xEB01 0x01C4      ADD      R1,R1,R4, LSL #+3
   \       0x1C   0xE9D1 0x4500      LDRD     R4,R5,[R1, #+0]
   \       0x20   0x6811             LDR      R1,[R2, #+0]
   \       0x22   0xEB00 0x01C1      ADD      R1,R0,R1, LSL #+3
   \       0x26   0xE9C1 0x4500      STRD     R4,R5,[R1, #+0]
     39            }
   \                     ??initMap_0: (+1)
   \       0x2A   0x6811             LDR      R1,[R2, #+0]
   \       0x2C   0x1E49             SUBS     R1,R1,#+1
   \       0x2E   0x4299             CMP      R1,R3
   \       0x30   0xDBED             BLT.N    ??initMap_1
     40          }
   \       0x32   0xBC30             POP      {R4,R5}
   \       0x34   0x4770             BX       LR
     41          

   \                                 In section .text, align 2, keep-with-next
     42          void sortMap(Point *map, const int *map_size) {
   \                     sortMap: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
     43            int size = *map_size;
   \        0x4   0x680B             LDR      R3,[R1, #+0]
     44          
     45            for (int i = 0; i < size; i++) {
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0xE01A             B.N      ??sortMap_0
     46              for (int j = i + 1; j < size; j++) {
     47                if (map[i].x > map[j].x) {
   \                     ??sortMap_1: (+1)
   \        0xA   0xF852 0x0037      LDR      R0,[R2, R7, LSL #+3]
   \        0xE   0xF852 0x1036      LDR      R1,[R2, R6, LSL #+3]
   \       0x12   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x16   0xD20F             BCS.N    ??sortMap_2
     48                  Point tmp = map[i];
   \       0x18   0xEB02 0x04C6      ADD      R4,R2,R6, LSL #+3
   \       0x1C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
     49                  map[i] = map[j];
   \       0x20   0xEB02 0x0CC7      ADD      R12,R2,R7, LSL #+3
   \       0x24   0xE9DC 0x4500      LDRD     R4,R5,[R12, #+0]
   \       0x28   0xEB02 0x0CC6      ADD      R12,R2,R6, LSL #+3
   \       0x2C   0xE9CC 0x4500      STRD     R4,R5,[R12, #+0]
     50                  map[j] = tmp;
   \       0x30   0xEB02 0x04C7      ADD      R4,R2,R7, LSL #+3
   \       0x34   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
     51                }
     52              }
   \                     ??sortMap_2: (+1)
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??sortMap_3: (+1)
   \       0x3A   0x429F             CMP      R7,R3
   \       0x3C   0xDBE5             BLT.N    ??sortMap_1
   \       0x3E   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMap_0: (+1)
   \       0x40   0x429E             CMP      R6,R3
   \       0x42   0xDA01             BGE.N    ??sortMap_4
   \       0x44   0x1C77             ADDS     R7,R6,#+1
   \       0x46   0xE7F8             B.N      ??sortMap_3
     53            }
     54          }
   \                     ??sortMap_4: (+1)
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void sortMapByX(Point *map, const int *map_size) {
   \                     sortMapByX: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
     57            int size = *map_size;
   \        0x4   0x680B             LDR      R3,[R1, #+0]
     58          
     59            for (int i = 0; i < size; i++) {
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0xE01A             B.N      ??sortMapByX_0
     60              for (int j = i + 1; j < size; j++) {
     61                if (map[i].x > map[j].x) {
   \                     ??sortMapByX_1: (+1)
   \        0xA   0xF852 0x0037      LDR      R0,[R2, R7, LSL #+3]
   \        0xE   0xF852 0x1036      LDR      R1,[R2, R6, LSL #+3]
   \       0x12   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x16   0xD20F             BCS.N    ??sortMapByX_2
     62                  Point tmp = map[i];
   \       0x18   0xEB02 0x04C6      ADD      R4,R2,R6, LSL #+3
   \       0x1C   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
     63                  map[i] = map[j];
   \       0x20   0xEB02 0x0CC7      ADD      R12,R2,R7, LSL #+3
   \       0x24   0xE9DC 0x4500      LDRD     R4,R5,[R12, #+0]
   \       0x28   0xEB02 0x0CC6      ADD      R12,R2,R6, LSL #+3
   \       0x2C   0xE9CC 0x4500      STRD     R4,R5,[R12, #+0]
     64                  map[j] = tmp;
   \       0x30   0xEB02 0x04C7      ADD      R4,R2,R7, LSL #+3
   \       0x34   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
     65                }
     66              }
   \                     ??sortMapByX_2: (+1)
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??sortMapByX_3: (+1)
   \       0x3A   0x429F             CMP      R7,R3
   \       0x3C   0xDBE5             BLT.N    ??sortMapByX_1
   \       0x3E   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMapByX_0: (+1)
   \       0x40   0x429E             CMP      R6,R3
   \       0x42   0xDA01             BGE.N    ??sortMapByX_4
   \       0x44   0x1C77             ADDS     R7,R6,#+1
   \       0x46   0xE7F8             B.N      ??sortMapByX_3
     67            }
     68          }
   \                     ??sortMapByX_4: (+1)
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void sortMapByCCW(Point *map, const int *map_size) {
   \                     sortMapByCCW: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
     71            int size = *map_size;
   \        0x4   0x680F             LDR      R7,[R1, #+0]
     72          
     73            // except i == 0
     74            for (int i = 1; i < size; i++) {
   \        0x6   0x2501             MOVS     R5,#+1
   \        0x8   0xE023             B.N      ??sortMapByCCW_0
     75              for (int j = i + 1; j < size; j++) {
     76                if (getCCW(map[0], map[i], map[j]) > 0) {
   \                     ??sortMapByCCW_1: (+1)
   \        0xA   0xEB04 0x00C6      ADD      R0,R4,R6, LSL #+3
   \        0xE   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x12   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \       0x16   0xEB04 0x00C5      ADD      R0,R4,R5, LSL #+3
   \       0x1A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x1E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \       0x22   0x.... 0x....      BL       getCCW
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xDB0F             BLT.N    ??sortMapByCCW_2
     77                  Point tmp = map[i];
   \       0x2A   0xEB04 0x02C5      ADD      R2,R4,R5, LSL #+3
   \       0x2E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
     78                  map[i] = map[j];
   \       0x32   0xEB04 0x0CC6      ADD      R12,R4,R6, LSL #+3
   \       0x36   0xE9DC 0x2300      LDRD     R2,R3,[R12, #+0]
   \       0x3A   0xEB04 0x0CC5      ADD      R12,R4,R5, LSL #+3
   \       0x3E   0xE9CC 0x2300      STRD     R2,R3,[R12, #+0]
     79                  map[j] = tmp;
   \       0x42   0xEB04 0x02C6      ADD      R2,R4,R6, LSL #+3
   \       0x46   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
     80                }
     81              }
   \                     ??sortMapByCCW_2: (+1)
   \       0x4A   0x1C76             ADDS     R6,R6,#+1
   \                     ??sortMapByCCW_3: (+1)
   \       0x4C   0x42BE             CMP      R6,R7
   \       0x4E   0xDBDC             BLT.N    ??sortMapByCCW_1
   \       0x50   0x1C6D             ADDS     R5,R5,#+1
   \                     ??sortMapByCCW_0: (+1)
   \       0x52   0x42BD             CMP      R5,R7
   \       0x54   0xDA01             BGE.N    ??sortMapByCCW_4
   \       0x56   0x1C6E             ADDS     R6,R5,#+1
   \       0x58   0xE7F8             B.N      ??sortMapByCCW_3
     82            }
     83          }
   \                     ??sortMapByCCW_4: (+1)
   \       0x5A   0xBDF7             POP      {R0-R2,R4-R7,PC}
     84          
     85          // assign convex hull using by Graham's Scan Algorithm

   \                                 In section .text, align 2, keep-with-next
     86          void assignConvexHull(Point *map, int *map_size) {
   \                     assignConvexHull: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
     87            int size = *map_size;
   \        0x8   0xF8D8 0x9000      LDR      R9,[R8, #+0]
     88          
     89            // sort map by x
     90            sortMapByX(map, map_size);
   \        0xC   0x4641             MOV      R1,R8
   \        0xE   0x0038             MOVS     R0,R7
   \       0x10   0x.... 0x....      BL       sortMapByX
     91            // sort map by ccw
     92            sortMapByCCW(map, map_size);
   \       0x14   0x4641             MOV      R1,R8
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x.... 0x....      BL       sortMapByCCW
     93          
     94            // assign convex hull
     95            stack[stack_top++] = map[0];
   \       0x1C   0x....             LDR.N    R4,??DataTable3_2
   \       0x1E   0x....             LDR.N    R5,??DataTable3_3
   \       0x20   0xE9D7 0x0100      LDRD     R0,R1,[R7, #+0]
   \       0x24   0x6822             LDR      R2,[R4, #+0]
   \       0x26   0xEB05 0x02C2      ADD      R2,R5,R2, LSL #+3
   \       0x2A   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x6020             STR      R0,[R4, #+0]
     96            stack[stack_top++] = map[1];
   \       0x34   0xE9D7 0x0102      LDRD     R0,R1,[R7, #+8]
   \       0x38   0x6822             LDR      R2,[R4, #+0]
   \       0x3A   0xEB05 0x02C2      ADD      R2,R5,R2, LSL #+3
   \       0x3E   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x6020             STR      R0,[R4, #+0]
     97            for (int i = 2; i < size; i++) {
   \       0x48   0x2602             MOVS     R6,#+2
   \       0x4A   0xE029             B.N      ??assignConvexHull_0
     98              while (stack_top >= 2 && getCCW(stack[stack_top - 2], stack[stack_top - 1], map[i]) <= 0) {
     99                stack_top--;
   \                     ??assignConvexHull_1: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x6020             STR      R0,[R4, #+0]
    100              }
   \                     ??assignConvexHull_2: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x2802             CMP      R0,#+2
   \       0x56   0xDB16             BLT.N    ??assignConvexHull_3
   \       0x58   0xEB07 0x02C6      ADD      R2,R7,R6, LSL #+3
   \       0x5C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x60   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x6A   0x3808             SUBS     R0,R0,#+8
   \       0x6C   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0xEB05 0x00C0      ADD      R0,R5,R0, LSL #+3
   \       0x76   0xF1B0 0x0C10      SUBS     R12,R0,#+16
   \       0x7A   0xE9DC 0x0100      LDRD     R0,R1,[R12, #+0]
   \       0x7E   0x.... 0x....      BL       getCCW
   \       0x82   0x2801             CMP      R0,#+1
   \       0x84   0xDBE2             BLT.N    ??assignConvexHull_1
    101              stack[stack_top++] = map[i];
   \                     ??assignConvexHull_3: (+1)
   \       0x86   0xEB07 0x02C6      ADD      R2,R7,R6, LSL #+3
   \       0x8A   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x8E   0x6822             LDR      R2,[R4, #+0]
   \       0x90   0xEB05 0x02C2      ADD      R2,R5,R2, LSL #+3
   \       0x94   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x1C40             ADDS     R0,R0,#+1
   \       0x9C   0x6020             STR      R0,[R4, #+0]
    102            }
   \       0x9E   0x1C76             ADDS     R6,R6,#+1
   \                     ??assignConvexHull_0: (+1)
   \       0xA0   0x454E             CMP      R6,R9
   \       0xA2   0xDBD6             BLT.N    ??assignConvexHull_2
    103          
    104            // assign convex hull
    105            for (int i = 0; i < stack_top; i++) {
   \       0xA4   0x2200             MOVS     R2,#+0
   \       0xA6   0xE008             B.N      ??assignConvexHull_4
    106              map[i] = stack[i];
   \                     ??assignConvexHull_5: (+1)
   \       0xA8   0xEB05 0x03C2      ADD      R3,R5,R2, LSL #+3
   \       0xAC   0xE9D3 0x0100      LDRD     R0,R1,[R3, #+0]
   \       0xB0   0xEB07 0x03C2      ADD      R3,R7,R2, LSL #+3
   \       0xB4   0xE9C3 0x0100      STRD     R0,R1,[R3, #+0]
    107            }
   \       0xB8   0x1C52             ADDS     R2,R2,#+1
   \                     ??assignConvexHull_4: (+1)
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x4282             CMP      R2,R0
   \       0xBE   0xDBF3             BLT.N    ??assignConvexHull_5
    108          
    109            *map_size = stack_top;
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0xF8C8 0x0000      STR      R0,[R8, #+0]
    110          
    111            stack_top = 0;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x6020             STR      R0,[R4, #+0]
    112          }
   \       0xCA   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}
    113          

   \                                 In section .text, align 2, keep-with-next
    114          void calcAndStoreMidPoints(Point *map_Source, Point *map_Target, const int *map_SourceSize, int *map_TargetSize) {
   \                     calcAndStoreMidPoints: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x469A             MOV      R10,R3
    115            int size = *map_SourceSize;
   \        0xA   0x6814             LDR      R4,[R2, #+0]
    116            int targetIndex = -1;
   \        0xC   0xF05F 0x35FF      MOVS     R5,#+4294967295
    117          
    118            for (int i = 0; i < size; i++) {
   \       0x10   0x2600             MOVS     R6,#+0
   \       0x12   0xE043             B.N      ??calcAndStoreMidPoints_0
    119              Point midPoint;
    120              midPoint.x = (map_Source[(i - 1 + size) % size].x + map_Source[(i + 1) % size].x) / 2;
   \                     ??calcAndStoreMidPoints_1: (+1)
   \       0x14   0x19A0             ADDS     R0,R4,R6
   \       0x16   0x1E40             SUBS     R0,R0,#+1
   \       0x18   0x1C72             ADDS     R2,R6,#+1
   \       0x1A   0xFB90 0xF1F4      SDIV     R1,R0,R4
   \       0x1E   0xFB04 0x0011      MLS      R0,R4,R1,R0
   \       0x22   0xF857 0x1030      LDR      R1,[R7, R0, LSL #+3]
   \       0x26   0xFB92 0xF0F4      SDIV     R0,R2,R4
   \       0x2A   0xFB04 0x2210      MLS      R2,R4,R0,R2
   \       0x2E   0xF857 0x0032      LDR      R0,[R7, R2, LSL #+3]
   \       0x32   0x.... 0x....      BL       __aeabi_fadd
   \       0x36   0xF05F 0x4180      MOVS     R1,#+1073741824
   \       0x3A   0x.... 0x....      BL       __aeabi_fdiv
   \       0x3E   0x4680             MOV      R8,R0
    121              midPoint.y = (map_Source[(i - 1 + size) % size].y + map_Source[(i + 1) % size].y) / 2;
   \       0x40   0x19A0             ADDS     R0,R4,R6
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x1C71             ADDS     R1,R6,#+1
   \       0x46   0xFB90 0xF2F4      SDIV     R2,R0,R4
   \       0x4A   0xFB04 0x0012      MLS      R0,R4,R2,R0
   \       0x4E   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \       0x52   0x6840             LDR      R0,[R0, #+4]
   \       0x54   0xFB91 0xF2F4      SDIV     R2,R1,R4
   \       0x58   0xFB04 0x1112      MLS      R1,R4,R2,R1
   \       0x5C   0xEB07 0x01C1      ADD      R1,R7,R1, LSL #+3
   \       0x60   0x6849             LDR      R1,[R1, #+4]
   \       0x62   0x.... 0x....      BL       __aeabi_fadd
   \       0x66   0xF05F 0x4180      MOVS     R1,#+1073741824
   \       0x6A   0x.... 0x....      BL       __aeabi_fdiv
   \       0x6E   0x4681             MOV      R9,R0
    122          
    123              if (targetIndex == -1 || getDistance(midPoint, map_Target[targetIndex - 1]) > THRESHOLD) {
   \       0x70   0xF115 0x0F01      CMN      R5,#+1
   \       0x74   0xD00C             BEQ.N    ??calcAndStoreMidPoints_2
   \       0x76   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x7A   0x3808             SUBS     R0,R0,#+8
   \       0x7C   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0x80   0x4640             MOV      R0,R8
   \       0x82   0x4649             MOV      R1,R9
   \       0x84   0x.... 0x....      BL       getDistance
   \       0x88   0x....             LDR.N    R1,??DataTable3_4
   \       0x8A   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x8E   0xD804             BHI.N    ??calcAndStoreMidPoints_3
    124                map_Target[++targetIndex] = midPoint;
   \                     ??calcAndStoreMidPoints_2: (+1)
   \       0x90   0x1C6D             ADDS     R5,R5,#+1
   \       0x92   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x96   0xE9C0 0x8900      STRD     R8,R9,[R0, #+0]
    125              }
    126            }
   \                     ??calcAndStoreMidPoints_3: (+1)
   \       0x9A   0x1C76             ADDS     R6,R6,#+1
   \                     ??calcAndStoreMidPoints_0: (+1)
   \       0x9C   0x42A6             CMP      R6,R4
   \       0x9E   0xDBB9             BLT.N    ??calcAndStoreMidPoints_1
    127          
    128            target_Map_Idx = targetIndex;
   \       0xA0   0x....             LDR.N    R0,??DataTable3_5
   \       0xA2   0x6005             STR      R5,[R0, #+0]
    129            *map_TargetSize = targetIndex + 1;
   \       0xA4   0x1C6D             ADDS     R5,R5,#+1
   \       0xA6   0xF8CA 0x5000      STR      R5,[R10, #+0]
    130          }
   \       0xAA   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x3F00'0001        DC32     0x3f000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     init_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     stack_top

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x3F80'0001        DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x....'....        DC32     target_Map_Idx

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   assignConvexHull
        40   -> getCCW
        40   -> sortMapByCCW
        40   -> sortMapByX
      40   calcAndStoreMidPoints
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> getDistance
        40 __aeabi_cfrcmple
      40   getCCW
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40 __aeabi_cfcmple
        40 __aeabi_cfrcmple
      24   getDistance
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
        24   -> sqrtf
       8   initMap
      24   sortMap
        24 __aeabi_cfcmple
      32   sortMapByCCW
        32   -> getCCW
      24   sortMapByX
        24 __aeabi_cfcmple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
     206  assignConvexHull
     174  calcAndStoreMidPoints
     144  getCCW
      64  getDistance
      54  initMap
      32  init_map
      74  sortMap
      92  sortMapByCCW
      74  sortMapByX
     800  source_Map
       4  source_Map_Idx
       4  source_Map_size
     800  stack
       4  stack_top
     800  target_Map
       4  target_Map_Idx
       4  target_Map_size

 
 2'420 bytes in section .bss
    32 bytes in section .rodata
   906 bytes in section .text
 
   906 bytes of CODE  memory
    32 bytes of CONST memory
 2'420 bytes of DATA  memory

Errors: none
Warnings: none
